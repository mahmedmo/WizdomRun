"""Initial migration

Revision ID: 2d519de3a00d
Revises: 
Create Date: 2025-02-16 15:50:34.270476

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '2d519de3a00d'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
        sa.Column('userID', sa.VARCHAR(), autoincrement=False, nullable=False),
        sa.Column('screenName', sa.VARCHAR(length=31), autoincrement=False, nullable=False),
        sa.Column('createdAt', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
        sa.PrimaryKeyConstraint('userID', name='users_pkey'),
        sa.UniqueConstraint('screenName', name='users_screenName_key'),
        postgresql_ignore_search_path=False
    )
    op.create_table('player_character',
        sa.Column('characterID', sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column('userID', sa.VARCHAR(), autoincrement=False, nullable=False),
        sa.Column('modelID', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('hairID', sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column('robeID', sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column('bootID', sa.INTEGER(), autoincrement=False, nullable=True),
        sa.ForeignKeyConstraint(['userID'], ['users.userID'], name='player_character_userID_fkey', ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('characterID', name='player_character_pkey')
    )
    op.create_table('campaign',
        sa.Column('campaignID', sa.INTEGER(), server_default=sa.text("nextval('campaign_campaignID_seq'::regclass)"), autoincrement=True, nullable=False),
        sa.Column('lastUpdated', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
        sa.Column('userID', sa.VARCHAR(), autoincrement=False, nullable=False),
        sa.Column('title', sa.VARCHAR(length=127), autoincrement=False, nullable=False),
        sa.Column('campaignLength', postgresql.ENUM('quest', 'odyssey', 'saga', name='length_type'), autoincrement=False, nullable=False),
        sa.Column('currLevel', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('remainingTries', sa.INTEGER(), server_default=sa.text('2'), autoincrement=False, nullable=False),
        sa.ForeignKeyConstraint(['userID'], ['users.userID'], name='campaign_userID_fkey', ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('campaignID', name='campaign_pkey'),
        sa.UniqueConstraint('title', name='campaign_title_key'),
        postgresql_ignore_search_path=False
    )
    op.create_table('player_stats',
        sa.Column('campaignID', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('attack', sa.NUMERIC(precision=2, scale=1), autoincrement=False, nullable=False),
        sa.Column('hp', sa.INTEGER(), server_default=sa.text('100'), autoincrement=False, nullable=False),
        sa.Column('mana', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
        sa.Column('affinity', postgresql.ENUM('fire', 'earth', 'water', 'air', name='playerClass'), autoincrement=False, nullable=True),
        sa.CheckConstraint('attack >= 1::numeric AND attack <= 5::numeric', name='player_stats_attack_check'),
        sa.ForeignKeyConstraint(['campaignID'], ['campaign.campaignID'], name='player_stats_campaignID_fkey', ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('campaignID', name='player_stats_pkey')
    )
    op.create_table('questions',
        sa.Column('questionID', sa.INTEGER(), server_default=sa.text("nextval('questions_questionID_seq'::regclass)"), autoincrement=True, nullable=False),
        sa.Column('campaignID', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('difficulty', postgresql.ENUM('easy', 'medium', 'hard', name='question_difficulty'), autoincrement=False, nullable=False),
        sa.Column('questionStr', sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column('gotCorrect', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
        sa.Column('wrongAttempts', sa.INTEGER(), server_default=sa.text('0'), autoincrement=False, nullable=False),
        sa.ForeignKeyConstraint(['campaignID'], ['campaign.campaignID'], name='questions_campaignID_fkey', ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('questionID', name='questions_pkey'),
        postgresql_ignore_search_path=False
    )
    op.create_table('answers',
        sa.Column('answerID', sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column('questionID', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('answerStr', sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column('isCorrect', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
        sa.ForeignKeyConstraint(['questionID'], ['questions.questionID'], name='answers_questionID_fkey', ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('answerID', name='answers_pkey')
    )
    op.create_table('spells',
        sa.Column('spellID', sa.INTEGER(), server_default=sa.text("nextval('spells_spellID_seq'::regclass)"), autoincrement=True, nullable=False),
        sa.Column('spellName', sa.VARCHAR(length=31), autoincrement=False, nullable=False),
        sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column('spellElement', postgresql.ENUM('fire', 'earth', 'water', 'air', name='playerClass'), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint('spellID', name='spells_pkey'),
        postgresql_ignore_search_path=False
    )
    op.create_table('player_spells',
        sa.Column('playerspellID', sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column('playerID', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('spellID', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.ForeignKeyConstraint(['playerID'], ['player_stats.campaignID'], name='player_spells_playerID_fkey'),
        sa.ForeignKeyConstraint(['spellID'], ['spells.spellID'], name='player_spells_spellID_fkey'),
        sa.PrimaryKeyConstraint('playerspellID', name='player_spells_pkey')
    )
    op.create_table('achievements',
        sa.Column('achievementID', sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column('campaignID', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('title', sa.VARCHAR(length=63), autoincrement=False, nullable=False),
        sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
        sa.ForeignKeyConstraint(['campaignID'], ['campaign.campaignID'], name='achievements_campaignID_fkey', ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('achievementID', name='achievements_pkey')
    )
    op.execute("""
        CREATE OR REPLACE FUNCTION enforce_one_correct_answer()
        RETURNS TRIGGER AS $$
        BEGIN
            IF NEW."isCorrect" = TRUE THEN
                IF EXISTS (
                    SELECT 1 FROM answers 
                    WHERE "questionID" = NEW."questionID" 
                      AND "isCorrect" = TRUE
                      AND "answerID" <> NEW."answerID"
                ) THEN
                    RAISE EXCEPTION 'A question can only have one correct answer.';
                END IF;
            END IF;

            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    """)
    op.execute("""
        CREATE TRIGGER check_correct_answer
        BEFORE INSERT OR UPDATE ON answers
        FOR EACH ROW
        EXECUTE FUNCTION enforce_one_correct_answer();
    """)
    op.execute("""
        CREATE OR REPLACE FUNCTION enforce_answer_count()
        RETURNS TRIGGER AS $$
        DECLARE answer_count INT;
        BEGIN
            -- Count existing answers for the question
            SELECT COUNT(*) INTO answer_count FROM answers WHERE "questionID" = NEW."questionID";
            
            -- Ensure the count is either 0, 2, or 4
            IF NOT (answer_count = 0 OR answer_count = 2 OR answer_count = 4) THEN
                RAISE EXCEPTION 'Each question must have exactly 2 or 4 answers.';
            END IF;

            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    """)
    op.execute("""
        CREATE TRIGGER check_answer_count
        AFTER INSERT OR DELETE ON answers
        FOR EACH ROW
        EXECUTE FUNCTION enforce_answer_count();
    """)
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('achievements')
    op.drop_table('player_spells')
    op.drop_table('spells')
    op.drop_table('player_stats')
    op.drop_table('answers')
    op.drop_table('questions')
    op.drop_table('campaign')
    op.drop_table('player_character')
    op.drop_table('users')
    op.execute('DROP TYPE IF EXISTS length_type')
    op.execute('DROP TYPE IF EXISTS playerClass')
    op.execute('DROP TYPE IF EXISTS question_difficulty')
    op.execute("""
        DROP TRIGGER IF EXISTS check_answer_count ON answers;
    """)
    op.execute("""
        DROP TRIGGER IF EXISTS check_correct_answer ON answers;
    """)
    op.execute("""
        DROP FUNCTION IF EXISTS enforce_answer_count();
    """)
    op.execute("""
        DROP FUNCTION IF EXISTS enforce_one_correct_answer();
    """)
    # ### end Alembic commands ###